use std::collections::HashMap;
use std::path::Path;

use glam::{DVec4, DMat4, DVec3};

use super::{SceneBuilder, Props, Value};

grammar(builder: &mut SceneBuilder);

pub TopLevel = Statement*;

Statement: () = {
    "Include" <String> => builder.include(Path::new(<>)),
    "Import" <String> => builder.include(Path::new(<>)),
    "WorldBegin" => builder.world_begin(),
    "AttributeBegin" => builder.push(),
    "AttributeEnd" => builder.pop(),

    "ObjectBegin" <String> => builder.begin_object(<>),
    "ObjectEnd" => builder.end_object(),
    "ObjectInstance" <String> => builder.instance_object(<>),

    "Identity" => builder.identity(),
    "LookAt" <MaybeBracketed<(Vec3 Vec3 Vec3)>> => builder.look_at(<>),
    "Rotate" <MaybeBracketed<(Number Vec3)>> => builder.rotate(<>),
    "Translate" <MaybeBracketed<Vec3>> => builder.translate(<>),
    "Scale" <MaybeBracketed<Vec3>> => builder.scale(<>),
    "Transform" <MaybeBracketed<Mat4>> => builder.set_transform(<>),
    "ConcatTransform" <MaybeBracketed<Mat4>> => builder.apply_transform(<>),

    "Camera" <ty:String> <props:Properties> => builder.camera(ty, props.with_ctx("camera", ty)),

    "Shape" <ty:String> <props:Properties> => match ty {
        "sphere" => builder.sphere(props.with_ctx("shape", ty)),
        "trianglemesh" => builder.triangle_mesh(props.with_ctx("shape", ty)),
        "loopsubdiv" => builder.loop_subdivision_surface(props.with_ctx("shape", ty)),
        "plymesh" => builder.plymesh(props.with_ctx("shape", ty)),
        _ => builder.unrecognized_shape(ty),
    },

    "Texture" <name:String> <kind:String> <ty:String> <props:Properties> => match ty {
        "constant" => builder.constant_texture(name, props.with_ctx("texture", ty)),
        "scale" => builder.scale_texture(name, props.with_ctx("texture", ty)),
        "mix" => builder.mix_texture(name, props.with_ctx("texture", ty)),
        "checkerboard" => builder.checkerboard_texture(name, props.with_ctx("texture", ty)),
        "imagemap" => builder.image_texture(name, kind, props.with_ctx("texture", ty)),
        _ => builder.unrecognized_texture(ty),
    },

    "Material" <ty:String> <props:Properties> =>
        builder.material(ty, props.with_ctx("material", ty)),
    "MakeNamedMaterial" <name:String> <props:Properties> => {
        let ty = props.get_string("type").unwrap();
        builder.make_named_material(name, props.with_ctx("material", ty))
    },
    "NamedMaterial" <String> => builder.named_material(<>),

    "LightSource" <ty:String> <props:Properties> => match ty {
        "infinite" => builder.infinite_light(props.with_ctx("light", "infinite")),
        _ => builder.unrecognized_light(ty),
    },
    "AreaLightSource" <ty:String> <props:Properties> => match ty {
        "diffuse" => builder.diffuse_area_light(props.with_ctx("light", "diffuse")),
        _ => builder.unrecognized_area_light(ty),
    },

    Ident ! => builder.unrecognized(<>),
}

Properties: Props<'input> = (PropName Values)* => Props {
    map: <>.into_iter().map(|((ty, k), v)| (k, (ty, v))).collect(),
    used: Default::default(),
    ctx: "",
    domain: "",
};

Values: Vec<Value<'input>> = {
    Value => vec![<>],
    "[" <Value*> "]" => <>,
}

Value: Value<'input> = {
    String => Value::String(<>),
    Number => Value::Number(<>),
    "true" => Value::Boolean(true),
    "false" => Value::Boolean(false),
}

MaybeBracketed<T> = {
    "[" <T> "]",
    T
}

PropName: (&'input str, &'input str) = String => <>.split_once(' ').unwrap();

Vec3: DVec3 = Number Number Number => DVec3::new(<>);

Vec4: DVec4 = Number Number Number Number => DVec4::new(<>);

Mat4: DMat4 = Vec4 Vec4 Vec4 Vec4 => DMat4::from_cols(<>);

Number: f64 = r"-?(\d+(\.\d*)?|\.\d+)(e-?\d+)?" => <>.parse().unwrap();

String: &'input str = r#""[^"]*""# => <>.trim_matches('"');

Ident: &'input str = r"[a-zA-Z]\w*";

match {
    r"#[^\n]*" => {},
    r"\s*" => {},
} else {
    _
}
